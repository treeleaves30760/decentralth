{"version":3,"sources":["webpack:///./node_modules/@web3auth/wallet-connect-v1-adapter/dist/walletConnectV1Adapter.esm.js"],"names":["ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","WalletConnectV1Adapter","options","undefined","super","this","WALLET_CONNECT_V1","EIP155","EXTERNAL","NOT_READY","uri","adapterOptions","chainConfig","_this$connector","connector","connected","_this$wcProvider","wcProvider","provider","_","Error","checkInitializationRequirements","getWalletConnectInstance","config","emit","READY","status","rehydrated","onConnectHandler","accounts","chainId","toString","checkConnectionRequirements","notReady","_this$adapterOptions$","CONNECTING","adapterSettings","qrcodeModal","createNewSession","adapter","Promise","resolve","reject","on","async","error","payload","ERRORED","params","connectionError","concat","message","notConnectedError","cleanup","killSession","DISCONNECTED","_this$adapterOptions","_this$adapterOptions$2","opts","forceNewSession","pending","_this$chainConfig2","debug","err","_this$connector2","updateAdapterData","off","createSession","parseInt","catch","_this$chainConfig","invalidParams","connectedChainId","fromCode","setupProvider","subscribeEvents","CONNECTED","reconnected","walletConnectOptions","bridge"],"mappings":"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","file":"js/chunk-2d213b43.71e95b51.js","sourcesContent":["import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport WalletConnect from '@walletconnect/client';\nimport { BaseAdapter, WALLET_ADAPTERS, ADAPTER_NAMESPACES, CHAIN_NAMESPACES, ADAPTER_CATEGORY, ADAPTER_STATUS, getChainConfig, ADAPTER_EVENTS, WalletInitializationError, Web3AuthError, WalletLoginError, isHexStrict } from '@web3auth/base';\nimport { WalletConnectProvider } from '@web3auth/ethereum-provider';\nimport log from 'loglevel';\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nclass WalletConnectV1Adapter extends BaseAdapter {\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n\n    _defineProperty(this, \"name\", WALLET_ADAPTERS.WALLET_CONNECT_V1);\n\n    _defineProperty(this, \"adapterNamespace\", ADAPTER_NAMESPACES.EIP155);\n\n    _defineProperty(this, \"currentChainNamespace\", CHAIN_NAMESPACES.EIP155);\n\n    _defineProperty(this, \"type\", ADAPTER_CATEGORY.EXTERNAL);\n\n    _defineProperty(this, \"adapterOptions\", void 0);\n\n    _defineProperty(this, \"status\", ADAPTER_STATUS.NOT_READY);\n\n    _defineProperty(this, \"adapterData\", {\n      uri: \"\"\n    });\n\n    _defineProperty(this, \"connector\", null);\n\n    _defineProperty(this, \"wcProvider\", null);\n\n    _defineProperty(this, \"rehydrated\", false);\n\n    this.adapterOptions = _objectSpread({}, options);\n    this.chainConfig = options.chainConfig;\n  }\n\n  get connected() {\n    var _this$connector;\n\n    return !!((_this$connector = this.connector) !== null && _this$connector !== void 0 && _this$connector.connected);\n  }\n\n  get provider() {\n    var _this$wcProvider;\n\n    return ((_this$wcProvider = this.wcProvider) === null || _this$wcProvider === void 0 ? void 0 : _this$wcProvider.provider) || null;\n  }\n\n  set provider(_) {\n    throw new Error(\"Not implemented\");\n  }\n\n  async init() {\n    super.checkInitializationRequirements();\n\n    if (!this.chainConfig) {\n      this.chainConfig = getChainConfig(CHAIN_NAMESPACES.EIP155, 1);\n    } // Create a connector\n\n\n    this.connector = this.getWalletConnectInstance();\n    this.wcProvider = new WalletConnectProvider({\n      config: {\n        chainConfig: this.chainConfig\n      }\n    });\n    this.emit(ADAPTER_EVENTS.READY, WALLET_ADAPTERS.WALLET_CONNECT_V1);\n    this.status = ADAPTER_STATUS.READY;\n\n    if (this.connector.connected) {\n      this.rehydrated = true;\n      await this.onConnectHandler({\n        accounts: this.connector.accounts,\n        chainId: this.connector.chainId.toString()\n      });\n    }\n  }\n\n  async connect() {\n    super.checkConnectionRequirements();\n    if (!this.connector) throw WalletInitializationError.notReady(\"Wallet adapter is not ready yet\");\n\n    if (this.connected) {\n      await this.onConnectHandler({\n        accounts: this.connector.accounts,\n        chainId: this.connector.chainId.toString()\n      });\n      return this.provider;\n    }\n\n    if (this.status !== ADAPTER_STATUS.CONNECTING) {\n      var _this$adapterOptions$;\n\n      // for wallet connect qr code modal we have to create a new connector, coz wallet connect internally does not open\n      // modal again on existing instance if connection is pending.\n      if ((_this$adapterOptions$ = this.adapterOptions.adapterSettings) !== null && _this$adapterOptions$ !== void 0 && _this$adapterOptions$.qrcodeModal) {\n        this.connector = this.getWalletConnectInstance();\n      }\n\n      await this.createNewSession();\n      this.status = ADAPTER_STATUS.CONNECTING;\n      this.emit(ADAPTER_EVENTS.CONNECTING, {\n        adapter: WALLET_ADAPTERS.WALLET_CONNECT_V1\n      });\n    }\n\n    return new Promise((resolve, reject) => {\n      if (!this.connector) return reject(WalletInitializationError.notReady(\"Wallet adapter is not ready yet\")); // for wallet connect default modal.\n\n      this.connector.on(\"modal_closed\", async () => {\n        this.status = ADAPTER_STATUS.READY;\n        this.emit(ADAPTER_EVENTS.READY, WALLET_ADAPTERS.WALLET_CONNECT_V1);\n        return reject(new Error(\"User closed modal\"));\n      });\n\n      try {\n        // Subscribe to session connection\n        this.connector.on(\"connect\", async (error, payload) => {\n          if (error) {\n            this.emit(ADAPTER_EVENTS.ERRORED, error);\n          }\n\n          await this.onConnectHandler(payload.params[0]);\n          return resolve(this.provider);\n        });\n      } catch (error) {\n        log.error(\"Wallet connect v1 adapter error while connecting\", error); // ready again to be connected\n\n        this.status = ADAPTER_STATUS.READY;\n        this.rehydrated = true;\n        this.emit(ADAPTER_EVENTS.ERRORED, error);\n        reject(error instanceof Web3AuthError ? error : WalletLoginError.connectionError(\"Failed to login with wallet connect: \".concat((error === null || error === void 0 ? void 0 : error.message) || \"\")));\n      }\n    });\n  }\n\n  async getUserInfo() {\n    if (!this.connected) throw WalletLoginError.notConnectedError(\"Not connected with wallet, Please login/connect first\");\n    return {};\n  }\n\n  async disconnect() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      cleanup: false\n    };\n    const {\n      cleanup\n    } = options;\n    if (!this.connector || !this.connected) throw WalletLoginError.notConnectedError(\"Not connected with wallet\");\n    await this.connector.killSession();\n    this.rehydrated = false;\n\n    if (cleanup) {\n      this.connector = null;\n      this.status = ADAPTER_STATUS.NOT_READY;\n      this.wcProvider = null;\n    } else {\n      // ready to connect again\n      this.status = ADAPTER_STATUS.READY;\n    }\n\n    this.emit(ADAPTER_EVENTS.DISCONNECTED);\n  }\n\n  async createNewSession() {\n    var _this$adapterOptions, _this$adapterOptions$2;\n\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      forceNewSession: false\n    };\n    if (!this.connector) throw WalletInitializationError.notReady(\"Wallet adapter is not ready yet\");\n\n    if (opts.forceNewSession && this.connector.pending) {\n      await this.connector.killSession();\n    } // for wallet connect qr modal\n\n\n    if ((_this$adapterOptions = this.adapterOptions) !== null && _this$adapterOptions !== void 0 && (_this$adapterOptions$2 = _this$adapterOptions.adapterSettings) !== null && _this$adapterOptions$2 !== void 0 && _this$adapterOptions$2.qrcodeModal) {\n      var _this$chainConfig;\n\n      await this.connector.createSession({\n        chainId: parseInt(((_this$chainConfig = this.chainConfig) === null || _this$chainConfig === void 0 ? void 0 : _this$chainConfig.chainId) || \"0x1\", 16)\n      });\n      return;\n    } // for web3auth qr code modal\n\n\n    return new Promise((resolve, reject) => {\n      var _this$chainConfig2;\n\n      if (!this.connector) return reject(WalletInitializationError.notReady(\"Wallet adapter is not ready yet\"));\n      log.debug(\"creating new session for web3auth wallet connect\");\n      this.connector.on(\"display_uri\", async (err, payload) => {\n        var _this$connector2;\n\n        if (err) {\n          this.emit(ADAPTER_EVENTS.ERRORED, WalletLoginError.connectionError(\"Failed to display wallet connect qr code\"));\n          return reject(err);\n        }\n\n        const uri = payload.params[0];\n        this.updateAdapterData({\n          uri\n        });\n        (_this$connector2 = this.connector) === null || _this$connector2 === void 0 ? void 0 : _this$connector2.off(\"display_uri\");\n        return resolve();\n      });\n      this.connector.createSession({\n        chainId: parseInt(((_this$chainConfig2 = this.chainConfig) === null || _this$chainConfig2 === void 0 ? void 0 : _this$chainConfig2.chainId) || \"0x1\", 16)\n      }).catch(error => {\n        log.error(\"error while creating new wallet connect session\", error);\n        this.emit(ADAPTER_EVENTS.ERRORED, error);\n        return reject(error);\n      });\n    });\n  }\n\n  async onConnectHandler(params) {\n    if (!this.connector || !this.wcProvider) throw WalletInitializationError.notReady(\"Wallet adapter is not ready yet\");\n    if (!this.chainConfig) throw WalletInitializationError.invalidParams(\"Chain config is not set\");\n    const {\n      chainId\n    } = params;\n    log.debug(\"connected chainId\", chainId);\n    const connectedChainId = parseInt(chainId, isHexStrict(chainId) ? 16 : 10);\n\n    if (connectedChainId !== parseInt(this.chainConfig.chainId, 16)) {\n      // we need to create a new session since old session is already used and\n      // user needs to login again with correct chain with new qr code.\n      await this.createNewSession({\n        forceNewSession: true\n      });\n      this.emit(ADAPTER_EVENTS.ERRORED, WalletInitializationError.fromCode(5000, \"Not connected to correct chainId. Expected: \".concat(this.chainConfig.chainId, \", Current: \").concat(connectedChainId, \", Please switch to correct chain from wallet\")));\n      return;\n    }\n\n    await this.wcProvider.setupProvider(this.connector);\n    this.subscribeEvents(this.connector);\n    this.status = ADAPTER_STATUS.CONNECTED;\n    this.emit(ADAPTER_EVENTS.CONNECTED, {\n      adapter: WALLET_ADAPTERS.WALLET_CONNECT_V1,\n      reconnected: this.rehydrated\n    });\n  }\n\n  subscribeEvents(connector) {\n    connector.on(\"session_update\", async error => {\n      if (error) {\n        this.emit(ADAPTER_EVENTS.ERRORED, error);\n      }\n    });\n  }\n\n  getWalletConnectInstance() {\n    const walletConnectOptions = this.adapterOptions.adapterSettings || {};\n    walletConnectOptions.bridge = walletConnectOptions.bridge || \"https://bridge.walletconnect.org\"; // Create a connector\n\n    return new WalletConnect(walletConnectOptions);\n  }\n\n}\n\nexport { WalletConnectV1Adapter };\n//# sourceMappingURL=walletConnectV1Adapter.esm.js.map\n"],"sourceRoot":""}
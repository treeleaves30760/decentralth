(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-2d207813"],{a18e:function(n,i,t){"use strict";t.r(i),t.d(i,"OpenloginAdapter",(function(){return u})),t.d(i,"getOpenloginDefaultOptions",(function(){return d}));var e=t("cdfa"),o=t("b089"),a=t("9523"),r=t.n(a),s=t("da81"),c=t.n(s),h=t("5c7d"),l=t.n(h);const d=(n,i)=>({adapterSettings:{network:e["b"].MAINNET,clientId:"",uxMode:e["c"].POPUP},chainConfig:n?Object(o["m"])(n,i):void 0,loginSettings:{relogin:!0}});function p(n,i){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var e=Object.getOwnPropertySymbols(n);i&&(e=e.filter((function(i){return Object.getOwnPropertyDescriptor(n,i).enumerable}))),t.push.apply(t,e)}return t}function g(n){for(var i=1;i<arguments.length;i++){var t=null!=arguments[i]?arguments[i]:{};i%2?p(Object(t),!0).forEach((function(i){r()(n,i,t[i])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):p(Object(t)).forEach((function(i){Object.defineProperty(n,i,Object.getOwnPropertyDescriptor(t,i))}))}return n}class u extends o["e"]{constructor(n){var i,t,a;super(),r()(this,"name",o["i"].OPENLOGIN),r()(this,"adapterNamespace",o["c"].MULTICHAIN),r()(this,"type",o["a"].IN_APP),r()(this,"openloginInstance",null),r()(this,"status",o["d"].NOT_READY),r()(this,"currentChainNamespace",o["f"].EIP155),r()(this,"openloginOptions",void 0),r()(this,"loginSettings",{}),r()(this,"privKeyProvider",null),l.a.debug("const openlogin adapter",n);const s=d(null===(i=n.chainConfig)||void 0===i?void 0:i.chainNamespace,null===(t=n.chainConfig)||void 0===t?void 0:t.chainId);if(this.openloginOptions=g(g({clientId:"",network:e["b"].MAINNET},s.adapterSettings),n.adapterSettings||{}),this.loginSettings=g(g({},s.loginSettings),n.loginSettings),null!==(a=n.chainConfig)&&void 0!==a&&a.chainNamespace){var c;this.currentChainNamespace=null===(c=n.chainConfig)||void 0===c?void 0:c.chainNamespace;const i=s.chainConfig?s.chainConfig:{};if(this.chainConfig=g(g({},i),null===n||void 0===n?void 0:n.chainConfig),l.a.debug("const openlogin chainConfig",this.chainConfig),!this.chainConfig.rpcTarget)throw o["j"].invalidParams("rpcTarget is required in chainConfig")}}get chainConfigProxy(){return this.chainConfig?g({},this.chainConfig):null}get provider(){var n;return(null===(n=this.privKeyProvider)||void 0===n?void 0:n.provider)||null}set provider(n){throw new Error("Not implemented")}async init(n){var i;if(super.checkInitializationRequirements(),null===(i=this.openloginOptions)||void 0===i||!i.clientId)throw o["j"].invalidParams("clientId is required before openlogin's initialization");if(!this.chainConfig)throw o["j"].invalidParams("chainConfig is required before initialization");this.openloginInstance=new e["d"](this.openloginOptions);const t=Object(e["e"])();let a=!0;Object.keys(t).length>0&&t.result&&(a=!0),await this.openloginInstance.init(),this.status=o["d"].READY,this.emit(o["b"].READY,o["i"].OPENLOGIN);try{this.openloginInstance.privKey&&(n.autoConnect||a)&&await this.connect()}catch(r){l.a.error("Failed to connect with cached openlogin provider",r),this.emit("ERRORED",r)}}async connect(n){super.checkConnectionRequirements(),this.status=o["d"].CONNECTING,this.emit(o["b"].CONNECTING,g(g({},n),{},{adapter:o["i"].OPENLOGIN}));try{return await this.connectWithProvider(n),this.provider}catch(i){if(l.a.error("Failed to connect with openlogin provider",i),this.status=o["d"].READY,this.emit(o["b"].ERRORED,i),null!==i&&void 0!==i&&i.message.includes("user closed popup"))throw o["k"].popupClosed();throw o["k"].connectionError("Failed to login with openlogin")}}async disconnect(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{cleanup:!1};if(this.status!==o["d"].CONNECTED)throw o["k"].notConnectedError("Not connected with wallet");if(!this.openloginInstance)throw o["j"].notReady("openloginInstance is not ready");await this.openloginInstance.logout(),n.cleanup?(this.status=o["d"].NOT_READY,this.openloginInstance=null,this.privKeyProvider=null):this.status=o["d"].READY,this.emit(o["b"].DISCONNECTED)}async getUserInfo(){if(this.status!==o["d"].CONNECTED)throw o["k"].notConnectedError("Not connected with wallet");if(!this.openloginInstance)throw o["j"].notReady("openloginInstance is not ready");const n=await this.openloginInstance.getUserInfo();return n}setAdapterSettings(n){if(this.status===o["d"].READY)return;const i=d();this.openloginOptions=g(g(g({},i.adapterSettings),this.openloginOptions||{}),n)}setChainConfig(n){super.setChainConfig(n),this.currentChainNamespace=n.chainNamespace}async connectWithProvider(n){if(!this.chainConfig)throw o["j"].invalidParams("chainConfig is required before initialization");if(!this.openloginInstance)throw o["j"].notReady("openloginInstance is not ready");if(this.currentChainNamespace===o["f"].SOLANA){const{SolanaPrivateKeyProvider:n}=await Promise.all([t.e("chunk-ec9b4d14"),t.e("chunk-bea95fd4"),t.e("chunk-05e3f6e8")]).then(t.bind(null,"7b09"));this.privKeyProvider=new n({config:{chainConfig:this.chainConfig}})}else{if(this.currentChainNamespace!==o["f"].EIP155)throw new Error("Invalid chainNamespace: ".concat(this.currentChainNamespace," found while connecting to wallet"));{const{EthereumPrivateKeyProvider:n}=await Promise.all([t.e("chunk-ec9b4d14"),t.e("chunk-12da4c05")]).then(t.bind(null,"1e6b"));this.privKeyProvider=new n({config:{chainConfig:this.chainConfig}})}}!this.openloginInstance.privKey&&n&&await this.openloginInstance.login(c()(this.loginSettings,{loginProvider:n.loginProvider},{extraLoginOptions:{login_hint:null===n||void 0===n?void 0:n.login_hint}}));let i=this.openloginInstance.privKey;if(i){if(this.currentChainNamespace===o["f"].SOLANA){const{getED25519Key:n}=await Promise.all([t.e("chunk-bea95fd4"),t.e("chunk-2d0c209b")]).then(t.bind(null,"4933"));i=n(i).sk.toString("hex")}await this.privKeyProvider.setupProvider(i),this.status=o["d"].CONNECTED,this.emit(o["b"].CONNECTED,{adapter:o["i"].OPENLOGIN,reconnected:!n})}}}}}]);
//# sourceMappingURL=chunk-2d207813.1941f9b2.js.map